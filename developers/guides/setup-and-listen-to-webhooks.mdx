---
title: "Set up and listen for webhooks"
description: "Learn how to set up a webhook using Node.js and Ngrok to receive notifications from Livepeer."
---

A webhook trigger event refers to a specific occurrence or action in Livepeer that prompts the webhook to send data to another system. You can learn more about the different webhook events [here](/developers/core-concepts/studio/webhook-event).

Livepeer Studio uses webhooks to communicate with your application
asynchronously when events for your stream occur. For example, you may want to
know when a stream has `active` or `idle`, so that you can surface this
information to viewers.

When these events happen, you can make a `POST` request
to a URL that you specify.

Setting up a webhook using Node.js and Ngrok allows you to receive real-time data from Livepeer. In this guide, we'll walk you through the steps to set up a webhook using Node.js and Ngrok to receive notifications from Livepeer.

### Create a New Node.js Project

Open your terminal and create a new directory for your project:

```sh
mkdir webhook-project
cd webhook-project
```

Next, initialize a new Node.js project:

```sh
npm init -y
```

### Install Dependencies

You'll need the Express.js framework to create a web server and the body-parser middleware to parse incoming JSON data.

```sh
npm install express body-parser --save
```

### Create an Express.js Server

Create an `app.js` file in your project directory and set up an Express.js server:

```js
const express = require("express");
const bodyParser = require("body-parser");
const app = express();
const port = 3000;

// Parse JSON requests
app.use(bodyParser.json());

// Define a route to handle incoming webhook data
app.post("/webhook", (req, res) => {
  const payload = req.body;
  console.log("Received webhook data:", payload);
  // Handle the webhook data here
  res.sendStatus(200);
});

// Start the server
app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
```

next, run your Express server using the following command:

```
node app.js
```

Your Express server is now running locally on http://localhost:3000.

<Info>
  In this case, we're using Ngrok to expose our local server to the internet. If
  you're running your server on a remote server, you can skip the next step. And
  for production applications, you'll want to deploy your server to a cloud
  provider like AWS or Heroku.
</Info>

### Set Up Ngrok

Ngrok will create a secure tunnel to expose your local server to the internet. In a new terminal window, run the following command:

```sh
ngrok http 3000
```

If you don't have Ngrok installed, you can download it [here](https://ngrok.com/download).

Ngrok will provide a public URL (e.g., https://abc123.ngrok.io). You'll use this URL as your webhook endpoint.

### Set Up a Webhook in the Livepeer Studio

Log in to the [Livepeer Studio](https://studio.livepeer.org/) and navigate to the [Developers/Webhooks](https://livepeer.studio/dashboard/developers/webhooks) page.

<Frame>![Webhooks](/images/webhooks.png)</Frame>

Click the "Create Webhook" button and enter your Ngrok URL as the webhook endpoint.
Select the an event to receive notifications for and click "Create Webhook".

That is it! You should now receive webhook notifications for the event you selected.

## Webhook Signatures

You can verify webhook requests that Livepeer Studio sends to your endpoints,
using the request header signature included by Livepeer Studio. This signature
will help you verify the incoming request comes from Livepeer Studio and not a
third party.

- Livepeer Studio will include a signature in each eventâ€™s `Livepeer-Signature`
  header.

- The timestamp is prefixed by `t=` and the signature is prefixed by a scheme.

- Schemes start with `v`, followed by an integer. Currently, the only valid
  signature scheme is v1. Livepeer Studio generates signatures using HMAC with
  SHA2-256.

```
Livepeer-Signature: t=36285904404,v1=88f3ff0fds9sf8a98vb0b096e81507cfd5c932fc17cf63a4a55566fd38da3a2d3d2
```

## Validate the signature, take the following steps:

### Extract the timestamp and signatures from the header

1. Split the header, using the `,` character as the separator, to get a list of
   elements.

2. Split each element, using the `=` character as the separator, to get a prefix
   and value pair.

- The value for the prefix `t` corresponds to the timestamp, and
- `v1` corresponds to the signature (or signatures). You can discard all other
  elements.

### Prepare the signed_payload string

The `signed_payload` is the raw request payload.

It is important to **Note:** that the `JSON` in the request payload includes the
same `timestamp` from the signature header to protect against replay attacks.

### Determine the expected signature

Compare the signature (or signatures) in the header to the expected signature.

- **For an equality match** compute the difference between the current timestamp
  and the received timestamp, then decide if the difference is within your
  tolerance.

- **To protect against timing attacks:** use a constant-time string comparison
  to compare the expected signature to each of the received signatures.
